//print(1.ToString().Substring(0),"\n");
print(1+1>=2+1);
string ptrstr = "hogehoge";
WriteMemory((VarPtr(ptrstr)+4),65);
WriteMemory((VarPtr(ptrstr)+5),66);
WriteMemory((VarPtr(ptrstr)+6),67);
WriteMemory((VarPtr(ptrstr)+7),68);
print("ポインタを取得",ptrstr,VarPtr(ptrstr),"ToString",VarPtr(ptrstr.ToString()),"Substring",VarPtr(ptrstr.Substring(1)));
var a = new ｱｱｱｳｱｱ;あいうえお表示
/*a.huge = "hage";
print(a.huge);
print(a.func_test(),a.huga());
print(a.huga.ToString().Substring(1));*/
car ary = new Array(100);
int i = 0;
for(i=0;i<100;i++)
{
	ary[i]=new Array(100);//YOSHI
	int j = 0;
	for(j=0;j<100;j++)
	{
		ary[i][j]=j;
	}
}
//print("演算子の定義",a+"hoge");
var cout = new costream;
cout << "std::cout" << "のような物" << 1 << "+" << 1 << "=" << (1 + 1) << endl << 
"演算順位てすと" << (2 * 2 + 2) << (2 * (2 + 2)) << endl <<
endl <<
//"getline" << (getline()) << endl <<
"ToString" << "TEST" << a << tab << (a.ToString()) << endl <<
"Array" /*<< ary*/ << endl
;
//a.huga = null;
//free(ｱｱｱｳｱｱ);//classを無理矢理削除してみる->new ｱｱｱｳｱｱするとC0000005
//GC();//これをすると二回目以降の実行がおかしくなる->一応解決
//uncontrollGC("memory"+"leak"+"suru");
//uncontrollGC("memoryleaksinai");
/**
free(Object...)
	GCの管理外にしてメモリを開放
uncontrollGC(Object...)
	GCの管理外にするがメモリは開放しない
	freeする必要がある
print(Object...)
	引数の内容をtab区切りにして表示
Object.ToString()
	文字列化
String.Substring(Int[,Int])
	文字切り出し
*/
class ｱｱｱｳｱｱ//comment
{
/*
	testetst
	/*
		ネスト可能
		/*/*/**/*/*/
	*/
*/
	var huge;
	int huga;
	var func_test()
	{
	//関数を上書きすることが可能
	//ただしclassの中で書き換えないとthisなどは参照不可
		this.huga = function(){return huge;}
		return this.huge;
	}
	var ToString()
	{
		return "HELLO";
	}
}
//STD????? LIB
class endl
{
	//empty class
}
class tab
{
	//empty class
}
/**
	Console Output Stream
*/
class costream
{
	var leftShift(var arg)
	{
		if(arg == endl)
		{
			print("\n");
			return this;
		}
		if(arg == tab)
		{
			print("\t");
			return this;
		}
		print(arg);
		return this;
	}
	var write(var arg)
	{
		print(arg);
	}
}
